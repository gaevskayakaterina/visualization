# -*- coding: utf-8 -*-
"""06_string_Гаевская_Екатерина_ПИ22-4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gy7YIfq2x93E7cDAzZXyC9hrSE43tlrY

# Работа со строковыми значениями

__Автор задач: Блохин Н.В. (NVBlokhin@fa.ru)__

Материалы:
* Макрушин С.В. Лекция "Работа со строковыми значениям"
* https://pyformat.info/
* https://docs.python.org/3/library/re.html
    * https://docs.python.org/3/library/re.html#flags
    * https://docs.python.org/3/library/re.html#functions
* https://pythonru.com/primery/primery-primeneniya-regulyarnyh-vyrazheniy-v-python
* https://kanoki.org/2019/11/12/how-to-use-regex-in-pandas/
* https://realpython.com/nltk-nlp-python/

## Задачи для совместного разбора

1. Вывести на экран данные из словаря `obj` построчно в виде `k = v`, задав формат таким образом, чтобы знак равенства оказался на одной и той же позиции во всех строках. Строковые литералы обернуть в кавычки.
"""

obj = {
    "home_page": "https://github.com/pypa/sampleproject",
    "keywords": "sample setuptools development",
    "license": "MIT",
}

"""2. Написать регулярное выражение,которое позволит найти номера групп студентов."""

obj = pd.Series(["Евгения гр.ПМ19-1", "Илья пм 20-4", "Анна 20-3"])
obj

' %d          :      %d '  % ( 1 , 2 )

"""3. Разбейте текст формулировки задачи 2 на слова.

## Лабораторная работа 6

### Форматирование строк

1\. Загрузите данные из файла `recipes_sample.csv` (__ЛР2__) в виде `pd.DataFrame` `recipes` При помощи форматирования строк выведите информацию об id рецепта и времени выполнения 5 случайных рецептов в виде таблицы следующего вида:

    
    |      id      |  minutes  |
    |--------------------------|
    |    61178     |    65     |
    |    202352    |    80     |
    |    364322    |    150    |
    |    26177     |    20     |
    |    224785    |    35     |
    
Обратите внимание, что ширина столбцов заранее неизвестна и должна рассчитываться динамически, в зависимости от тех данных, которые были выбраны.
"""

import pandas as pd
recipes = pd.read_csv('recipes_sample.csv')
print('|      id      |  minutes  |')
print('|--------------------------|')
for i in range(5):
  print(f'| {recipes["id"][i]:^12} | {recipes["minutes"][i]:^9} |')

"""2\. Напишите функцию `show_info`, которая по данным о рецепте создает строку (в смысле объекта python) с описанием следующего вида:

```
"Название Из Нескольких Слов"

1. Шаг 1
2. Шаг 2
----------
Автор: contributor_id
Среднее время приготовления: minutes минут
```

    
Данные для создания строки получите из файлов `recipes_sample.csv` (__ЛР2__) и `steps_sample.xml` (__ЛР3__). 
Вызовите данную функцию для рецепта с id `170895` и выведите (через `print`) полученную строку на экран.
"""

assert (
    show_info(
        name="george s at the cove black bean soup",
        steps=[
            "clean the leeks and discard the dark green portions",
            "cut the leeks lengthwise then into one-inch pieces",
            "melt the butter in a medium skillet , med",
        ],
        minutes=90,
        author_id=35193,
    )
    == '"George S At The Cove Black Bean Soup"\n\n1. Clean the leeks and discard the dark green portions\n2. Cut the leeks lengthwise then into one-inch pieces\n3. Melt the butter in a medium skillet , med\n----------\nАвтор: 35193\nСреднее время приготовления: 90 минут\n'
)

import xml.etree.ElementTree as ET

def Get_steps(recipe_id):
  list1=[]
  text = ".//recipe/[id = '" + str(recipe_id) + "']"
  a = root.findall(text)
  for steps in a[0].iter('step'):
    list1.append(steps.text)
  return list1

def show_info(name,minutes,contributor_id,steps):
  res1 = name + 'n\n'
  maxlen = 0
  for i,step in enumerate(steps):
    res1 += str(i+1) + '. ' + step + '\n'
    if len(step) > maxlen:
      maxlen = len(step)
    for i in range (maxlen + 4): res1 += '-'
    res1 += '\nАвтор: ' + str(contributor_id) + '\n'
    res1 += 'Среднее время приготовления: ' + str(minutes) + 'минут'
    return res1



tree = ET.parse('steps_sample.xml')
root = tree.getroot()
id = 72367     # указать номер рецепта 170895(нужного рецепта)
df1 = recipes.loc[recipes['id'] == id]
name = df1['name'].iloc[0]
minutes = df1['minutes'].iloc[0]
contributor_id = df1['contributor_id'].iloc[0]
steps = Get_steps(id)
print(show_info(name,minutes,contributor_id,steps))

import numpy as np
a = np.arange(10,110,10)
b = a.reshape((5,2))
b[1,1] = 0
a[:5].sum()

steps = Get_steps(id)
print(steps)
print(len(steps))

for i in range(len(steps)):
  print(f'| {recipes["id"][i]:^12} | {recipes["minutes"][i]:^9} |')

"""## Работа с регулярными выражениями

3\. Напишите регулярное выражение, которое ищет следующий паттерн в строке: число (1 цифра или более), затем пробел, затем слова: hour или hours или minute или minutes. Произведите поиск по данному регулярному выражению в каждом шаге рецепта с id 25082. Выведите на экран все непустые результаты, найденные по данному шаблону.
"""

import re 
regvir = ''

stro = show_info(name,minutes,contributor_id,steps)
print(stro)

import re
# в предыдущей программе указать номер рецепта 25082 (программа 2)
k = 0
print(len(steps))
for i in range(len(steps)):
  mi = re.search(r'd+ hourse|\d+ minutes|\d+ hour|\d+ minute',steps[i])
  if mi:
    print(mi[0])
    k = k + 1
  else:
    k = k
print(k)

"""4\. Напишите регулярное выражение, которое ищет шаблон вида "this..., but" _в начале строки_ . Между словом "this" и частью ", but" может находиться произвольное число букв, цифр, знаков подчеркивания и пробелов. Никаких других символов вместо многоточия быть не может. Пробел между запятой и словом "but" может присутствовать или отсутствовать.

Используя строковые методы `pd.Series`, выясните, для каких рецептов данный шаблон содержится в тексте описания. Выведите на экран количество таких рецептов и 3 примера подходящих описаний (текст описания должен быть виден на экране полностью).
"""

recipes = pd.read_csv('recipes_sample.csv')
#print(recipes)
patt = 'this[\w\s]*,(?:but| but)'
roc = recipes.loc[recipes.description.str.match(patt)==True]  #совпадение по паттерну
#print(roc)
for i in range(1,4):
  print(f"Рецепт № {i}:{roc.description.values[i]}")

"""5\. В текстах шагов рецептов обыкновенные дроби имеют вид "a / b". Используя регулярные выражения, уберите в тексте шагов рецепта с id 72367 пробелы до и после символа дроби. Выведите на экран шаги этого рецепта после их изменения."""

steps = Get_steps(id)
#указать в 2 программе id рецепта 72367
for i in range(len(steps)):
  mo = re.search(r'\d+ \/ \d+',steps[i])
  print(mo)
  if mo:
    foj = re.sub(r' / ', '/',steps[i])
    print(foj)

"""### Сегментация текста

6\. Разбейте тексты шагов рецептов на слова при помощи пакета `nltk`. Посчитайте и выведите на экран кол-во уникальных слов среди всех рецептов. Словом называется любая последовательность алфавитных символов (для проверки можно воспользоваться `str.isalpha`). При подсчете количества уникальных слов не учитывайте регистр.
"""

import nltk
import pandas as pd
nltk.download('punkt')
import xml.etree.ElementTree as xml
from nltk.tokenize import word_tokenize
tree = xml.parse('steps_sample.xml')
root = tree.getroot()
unik = set()

for item in root.iter('step'):
  str1 = item.text
  lw = nltk.word_tokenize(str1)
  for item in lw:
    if item.isalpha() == True:
      unik.add(item.lower())
      
print(len(unik))

"""7\. Разбейте описания рецептов из `recipes` на предложения при помощи пакета `nltk`. Найдите 5 самых длинных описаний (по количеству _предложений_) рецептов в датасете и выведите строки фрейма, соответствующие этим рецептами, в порядке убывания длины."""

import nltk
from nltk import sent_tokenize
#import numpy as np
import pandas as pd
def Senty(row):
  return len(nltk.sent_tokenize(row['description']))
  
recipes = recipes.dropna(subset = ['description'])
recipes['sentens'] = recipes.apply(Senty,axis = 1)
recipes = recipes.sort_values('sentens',ascending=False)
cols = recipes.columns.tolist()
cols = cols[-1:]+cols[:-1]
recipes = recipes[cols]
recipes = recipes.head(5)
print(recipes.to_string())

'''
recipes = pd.read_csv('recipes_sample.csv')
kolv = 0
obche = 0
for i in recipes.description[:3]:
  #print(i)
  #print(len(i))
  len(nltk.sent_tokenize(i))
 

len(nltk.sent_tokenize(recipes.description[3]))


черновик
recipes = pd.read_csv('recipes_sample.csv')
kolv = 0
obche = 0
for i in recipes.description[:3]:
  print(i)
  #print(len(i))
  for znak in i:
    if znak == '.' or znak == '!' or znak == '?':
      kolv += 1
  print(kolv)
  obche = obche + kolv
  kolv = 0
print(obche)
'''

"""8\. Напишите функцию, которая для заданного предложения выводит информацию о частях речи слов, входящих в предложение, в следующем виде:
```
PRP   VBD   DT      NNS     CC   VBD      NNS        RB   
 I  omitted the raspberries and added strawberries instead
``` 
Для определения части речи слова можно воспользоваться `nltk.pos_tag`.

Проверьте работоспособность функции на названии рецепта с id 241106.

Обратите внимание, что часть речи должна находиться ровно посередине над соотвествующим словом, а между самими словами должен быть ровно один пробел.

"""

print(recipes[:6])
'''
tokens ( list ( str ) ) — последовательность токенов, которые нужно пометить

tagset ( str ) — набор тегов, который будет использоваться, например, универсальный, wsj, коричневый

lang ( str ) – код языка по ISO 639, например, eng для английского, rus для русского.
'''

#from nltk import pos_tag, word_tokenize
#recipes.id[241106]
#a = recipes[lambda x: x['id'] == 241106]
#print(a.description)
#pos_tag(word_tokenize(a.description))

import nltk
from nltk import pos_tag, word_tokenize
#print(recipes[:6])
for i in recipes.index:
  if recipes.id[i] == 241106:
    ind = i
a = nltk.pos_tag([i for i in word_tokenize(recipes.name[ind])])
pro = ''
pro2 = ''
for i,j in dict(a).items():
  pro += f'{j: ^{len(i)+1}}'
  pro += i + ' '
print(pro)
print(pro2)